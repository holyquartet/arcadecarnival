<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Lava Parkour Game</title>
    <style>
        /* Add these CSS variables */
:root {
    --primary: #ff2a6d;
    --secondary: #05d9e8;
    --dark: #1a1a2e;
    --light: #d1f7ff;
    --accent: #ffd300;
}

/* Header Styles */
.arcade-header {
    background-color: rgba(0, 0, 0, 0.8);
    padding: 1rem 5%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: fixed;
    width: 100%;
    z-index: 100;
    top: 0;
    flex-wrap: wrap;
}

.arcade-logo {
    font-size: 1.8rem;
    font-weight: bold;
    color: var(--primary);
    text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary);
}

.arcade-logo span {
    color: var(--secondary);
    text-shadow: 0 0 10px var(--secondary), 0 0 20px var(--secondary);
}

.arcade-nav ul {
    display: flex;
    list-style: none;
    flex-wrap: wrap;
    justify-content: center;
}

.arcade-nav ul li {
    margin: 0.5rem 1rem;
}

.arcade-nav ul li a {
    color: var(--light);
    text-decoration: none;
    font-weight: bold;
    transition: color 0.3s;
    white-space: nowrap;
}

.arcade-nav ul li a:hover {
    color: var(--accent);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .arcade-header {
        padding: 0.8rem 3%;
        flex-direction: column;
    }
    
    .arcade-logo {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
    }
    
    .arcade-nav ul {
        margin-top: 0.5rem;
    }
    
    .arcade-nav ul li {
        margin: 0.3rem 0.8rem;
    }
    
    .arcade-nav ul li a {
        font-size: 0.9rem;
    }
}
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Arial', sans-serif;
            color: white;
        }
        canvas {
            display: block;
            margin: 20px auto;
            background: #000;
        }
        .game-container {
    position: relative;
    width: 100%;
    max-width: 100%;
    margin: 0 auto;
    text-align: center;
    padding: 80px 20px 0; /* Top padding to account for header */
    box-sizing: border-box;
}

@media (max-width: 768px) {
    .game-container {
        padding: 120px 20px 0; /* More top padding for stacked header */
    }
}
        .controls {
            color: white;
            margin: 20px auto;
            width: 100%;
            max-width: 100%;
            text-align: center;
            padding: 0 100px;
            box-sizing: border-box;
        }
        .title {
            color: #ff5500;
            font-size: 36px;
            margin: 10px 0;
            text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
        }
        .stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin: 0 auto 10px;
        }
        .score, .level-display {
            color: white;
            font-size: 24px;
            margin-left: 20px;
        }
        .audio-controls {
            display: flex;
            align-items: center;
        }
        .audio-controls button {
            background-color: #333;
            border: 1px solid #ff5500;
            color: white;
            margin-right: 10px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .audio-controls button:hover {
            background-color: #444;
        }
        .audio-controls button.active {
            background-color: #ff5500;
        }
        .volume-control {
            width: 100px;
            margin-left: 5px;
        }
        .game-over, .level-up, .pause-menu, .leaderboard-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            text-align: center;
            display: none;
            z-index: 10;
        }
        .game-over {
            z-index: 10;
        }
        .level-up {
            color: #ffff00;
            z-index: 10;
        }
        .pause-menu {
            background-color: rgba(0, 0, 0, 0.9);
            padding: 25px;
            border-radius: 10px;
            border: 2px solid #ff5500;
            z-index: 12;
            width: 350px;
        }
        .pause-menu h2 {
            color: #ff5500;
            margin-top: 0;
            text-shadow: 0 0 5px #ff0000;
        }
        .pause-menu .stats-display {
            margin: 15px 0;
            font-size: 18px;
            color: #00ffff;
        }
        .pause-menu .button-container {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .leaderboard-screen {
            background-color: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 10px;
            border: 2px solid #ff5500;
            z-index: 13;
            width: 400px;
        }
        .leaderboard-screen h2 {
            color: #ff5500;
            margin-top: 0;
            text-shadow: 0 0 5px #ff0000;
            font-size: 28px;
        }
        .leaderboard-screen .leaderboard-entries {
            margin: 20px 0;
            text-align: left;
        }
        .leaderboard-screen .button-container {
            margin-top: 20px;
        }
        .leaderboard h3 {
            color: #ff5500;
            margin: 0 0 10px 0;
            font-size: 18px;
            text-align: center;
            text-shadow: 0 0 5px #ff0000;
        }
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            border-bottom: 1px solid #333;
            padding-bottom: 3px;
        }
        .leaderboard-entry .rank {
            width: 20px;
            text-align: center;
            color: #ff8800;
        }
        .leaderboard-entry .name {
            flex: 1;
            padding-left: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .leaderboard-entry .stats {
            text-align: right;
            width: 80px;
            margin: 0;
            font-size: 14px;
            color: #00ffff;
        }
        button {
            background-color: #ff5500;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #ff7700;
        }
        input[type="text"] {
            padding: 8px;
            font-size: 16px;
            border-radius: 5px;
            border: 2px solid #ff5500;
            background-color: #222;
            color: white;
            width: 200px;
            text-align: center;
        }
        .game-loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .game-loading-content {
            text-align: center;
            color: white;
            max-width: 80%;
        }
        .game-loading-bar-container {
            width: 300px;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }
        .game-loading-bar {
            height: 100%;
            width: 0;
            background: linear-gradient(to right, #ff5500, #ffaa00);
            transition: width 0.3s;
        }
        .start-button {
            margin-top: 20px;
            padding: 12px 30px;
            background-color: #ff5500;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .start-button:hover {
            background-color: #ff7700;
        }
        .start-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <!-- Arcade Carnival Header -->
<header class="arcade-header">
    <div class="arcade-logo">Arcade<span>Carnival</span></div>
    <nav class="arcade-nav">
        <ul>
            <li><a href="#" onclick="showLeaderboardScreen()">Leaderboard</a></li>
            <li><a href="index.html">More Games</a></li>
        </ul>
    </nav>
</header>
    <div id="game-loading-screen" class="game-loading-screen">
        <div class="game-loading-content">
            <h2>Loading Game</h2>
            <div class="game-loading-bar-container">
                <div id="game-loading-bar" class="game-loading-bar"></div>
            </div>
            <p id="game-loading-status">Loading game...</p>
            <button id="start-game-button" class="start-button" disabled>Start Game</button>
        </div>
    </div>

    <div class="game-container">
        <h1 class="title">INFINITE LAVA PARKOUR</h1>
        <div class="stats">
            <div class="audio-controls">
                <button id="music-toggle" title="Toggle Music">â™«</button>
                <button id="sfx-toggle" title="Toggle Sound Effects">ðŸ”Š</button>
                <input type="range" id="volume-control" class="volume-control" min="0" max="100" value="50" title="Volume">
            </div>
            <div>
                <div class="level-display">Level: <span id="level-counter">1</span></div>
                <div class="score">Deaths: <span id="death-counter">0</span></div>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="game-over" id="game-over">
            <h2>GAME OVER</h2>
            <p>You fell into the lava!</p>
            <button id="restart-button">Try Again</button>
        </div>
        <div class="level-up" id="level-up">
            <h2>LEVEL COMPLETE!</h2>
            <p>Moving to level <span id="next-level">2</span></p>
        </div>
        <div class="pause-menu" id="pause-menu">
            <h2>GAME PAUSED</h2>
            <div class="stats-display">
                <p>Current Level: <span id="pause-level">1</span></p>
                <p>Deaths: <span id="pause-deaths">0</span></p>
            </div>
            <p>Enter your name to save score:</p>
            <input type="text" id="player-name" maxlength="15" placeholder="Your Name">
            <div class="button-container">
                <button id="save-end-button">Save & End Run</button>
                <button id="continue-button">Continue Run</button>
            </div>
        </div>
        <div class="leaderboard-screen" id="leaderboard-screen">
            <h2>TOP RUNNERS</h2>
            <div class="leaderboard-entries" id="leaderboard-entries">
                <!-- Leaderboard entries will be inserted here -->
            </div>
            <div class="button-container">
                <button id="new-game-button">New Game</button>
            </div>
        </div>
    </div>
    <div class="controls">
        <p>Use ARROW KEYS or A/D to move left and right, SPACE or W to jump. Double tap jump for a double jump!</p>
        <p>How far can you go? Watch out for exploding lava bubbles that activate when you get close!</p>
    </div>

    <script>
        // Enhanced Audio System
        const AudioManager = (function() {
            let audioContext;
            
            // Audio states
            let musicEnabled = true;
            let sfxEnabled = true;
            let volume = 0.5; // 0 to 1
            
            // Background music
            let backgroundMusic = null;
            let isMusicPlaying = false;
            
            // Sound effect buffers and sources
            const soundBuffers = {};
            let loadedSounds = 0;
            let totalSounds = 0;
            let loadingComplete = false;
            let onLoadProgress = null;
            let onLoadComplete = null;
            
            // Sound files configuration - define all sounds here
            const soundFiles = {
                jump: 'Sounds/jump.mp3',
                doubleJump: 'Sounds/doubleJump.mp3',
                death: 'Sounds/death.mp3',
                levelComplete: 'Sounds/levelComplete.mp3',
                lavaBubble: 'Sounds/lavaBubble.mp3',
                menuClick: 'Sounds/menuClick.mp3',
                landing: 'Sounds/landing.mp3',
                backgroundMusic: 'Sounds/background-music.mp3'
            };
            
            // Initialize audio context
            function init() {
                try {
                    // Create audio context with fallback
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContext();
                    
                    // Set up UI controls
                    setupControls();
                    
                    console.log("Audio system initialized successfully");
                    return true;
                } catch (error) {
                    console.error("Error initializing audio system:", error);
                    return false;
                }
            }
            
            // Set up UI controls for audio
            function setupControls() {
                const musicToggle = document.getElementById('music-toggle');
                const sfxToggle = document.getElementById('sfx-toggle');
                const volumeControl = document.getElementById('volume-control');
                
                // Set initial button states
                if (musicEnabled) musicToggle.classList.add('active');
                if (sfxEnabled) sfxToggle.classList.add('active');
                
                // Music toggle
                musicToggle.addEventListener('click', function() {
                    musicEnabled = !musicEnabled;
                    this.classList.toggle('active');
                    
                    if (musicEnabled) {
                        startMusic();
                    } else {
                        stopMusic();
                    }
                });
                
                // SFX toggle
                sfxToggle.addEventListener('click', function() {
                    sfxEnabled = !sfxEnabled;
                    this.classList.toggle('active');
                });
                
                // Volume control
                volumeControl.addEventListener('input', function() {
                    volume = this.value / 100;
                    updateVolume();
                });
            }
            
            // Load all game audio
            function preloadAudio(progressCallback, completeCallback) {
                onLoadProgress = progressCallback;
                onLoadComplete = completeCallback;
                
                totalSounds = Object.keys(soundFiles).length;
                loadedSounds = 0;
                
                // Start by resuming audio context (if suspended)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Load sound effects
                for (const [sound, filePath] of Object.entries(soundFiles)) {
                    if (sound === 'backgroundMusic') {
                        // Handle music separately
                        preloadMusic(filePath);
                    } else {
                        // Load sound effect
                        loadSoundBuffer(sound, filePath);
                    }
                }
            }
            
            // Load a sound file into buffer
            function loadSoundBuffer(name, url) {
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load sound file ${url}: ${response.status} ${response.statusText}`);
                        }
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        soundBuffers[name] = audioBuffer;
                        soundLoaded();
                        console.log(`Sound '${name}' loaded successfully`);
                    })
                    .catch(error => {
                        console.error(`Error loading sound '${name}' from ${url}:`, error);
                        // Count as loaded even if there's an error to avoid hanging
                        soundLoaded();
                    });
            }
            
            // Preload background music
            function preloadMusic(url) {
                backgroundMusic = new Audio(url);
                backgroundMusic.loop = true;
                backgroundMusic.volume = volume * 0.5; // Lower initial volume for music
                
                // Set up event listeners for music loading
                backgroundMusic.addEventListener('canplaythrough', function onCanPlay() {
                    backgroundMusic.removeEventListener('canplaythrough', onCanPlay);
                    soundLoaded();
                    console.log('Background music loaded successfully');
                });
                
                backgroundMusic.addEventListener('error', function(e) {
                    console.error('Error loading background music:', e);
                    // Count as loaded even if there's an error
                    soundLoaded();
                });
                
                // Start loading the music file
                backgroundMusic.load();
            }
            
            // Called when each sound is loaded
            function soundLoaded() {
                loadedSounds++;
                
                // Calculate and report progress
                const progress = (loadedSounds / totalSounds) * 100;
                if (onLoadProgress) {
                    onLoadProgress(progress);
                }
                
                // Check if all sounds are loaded
                if (loadedSounds >= totalSounds) {
                    loadingComplete = true;
                    if (onLoadComplete) {
                        onLoadComplete();
                    }
                }
            }
            
            // Start audio context (needs to be triggered by user interaction)
            function startAudioContext() {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed successfully');
                    }).catch(error => {
                        console.error('Failed to resume audio context:', error);
                    });
                    return true;
                }
                return false;
            }
            
            // Play a sound effect
            function playSfx(name, options = {}) {
                if (!sfxEnabled || !audioContext || audioContext.state !== 'running') return null;
                
                const buffer = soundBuffers[name];
                if (!buffer) {
                    console.warn(`Sound effect '${name}' not found`);
                    return null;
                }
                
                try {
                    // Create source and gain nodes
                    const source = audioContext.createBufferSource();
                    const gainNode = audioContext.createGain();
                    
                    // Connect nodes
                    source.buffer = buffer;
                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Set volume (with sound-specific adjustments)
                    let adjustedVolume = volume;
                    if (name === 'jump' || name === 'doubleJump') {
                        adjustedVolume *= 0.7; // Make jump sounds a bit quieter
                    } else if (name === 'death' || name === 'levelComplete') {
                        adjustedVolume *= 1.2; // Make important sounds a bit louder
                    } else if (name === 'menuClick') {
                        adjustedVolume *= 0.5; // Make UI sounds quieter
                    }
                    
                    // Apply volume (with optional override)
                    gainNode.gain.value = options.volume !== undefined ? options.volume : adjustedVolume;
                    
                    // Play sound
                    source.start(0);
                    
                    // Clean up when done
                    source.onended = function() {
                        source.disconnect();
                        gainNode.disconnect();
                    };
                    
                    return source;
                } catch (error) {
                    console.error(`Error playing sound '${name}':`, error);
                    return null;
                }
            }
            
            // Start background music
            function startMusic() {
                if (!musicEnabled || isMusicPlaying || !backgroundMusic) return false;
                
                try {
                    // Make sure volume is correct
                    backgroundMusic.volume = volume * 0.5;
                    
                    // Play music with error handling
                    const playPromise = backgroundMusic.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.error('Error playing background music:', error);
                            // If auto-play is prevented, we'll need user interaction
                            isMusicPlaying = false;
                        }).then(() => {
                            isMusicPlaying = true;
                        });
                    } else {
                        isMusicPlaying = true;
                    }
                    
                    return true;
                } catch (error) {
                    console.error('Error starting music:', error);
                    return false;
                }
            }
            
            // Stop background music
            function stopMusic() {
                if (!backgroundMusic) return false;
                
                try {
                    backgroundMusic.pause();
                    backgroundMusic.currentTime = 0;
                    isMusicPlaying = false;
                    return true;
                } catch (error) {
                    console.error('Error stopping music:', error);
                    return false;
                }
            }
            
            // Update volume levels for all audio
            function updateVolume() {
                // Update music volume
                if (backgroundMusic) {
                    backgroundMusic.volume = volume * 0.5;
                }
            }
            
            // Public API
            return {
                init: init,
                preloadAudio: preloadAudio,
                startAudioContext: startAudioContext,
                playSfx: playSfx,
                startMusic: startMusic,
                stopMusic: stopMusic,
                updateVolume: updateVolume
            };
        })();

        // Game variables and initialization
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameSpeedMultiplier = 1.4375; // Game speed multiplier (1.15 * 1.25)
        const gravity = 0.5 * gameSpeedMultiplier;
        const friction = 0.8;
        const deathCounter = document.getElementById('death-counter');
        const levelCounter = document.getElementById('level-counter');
        const nextLevelDisplay = document.getElementById('next-level');
        const gameOverScreen = document.getElementById('game-over');
        const levelUpScreen = document.getElementById('level-up');
        const pauseMenu = document.getElementById('pause-menu');
        const pauseLevelDisplay = document.getElementById('pause-level');
        const pauseDeathsDisplay = document.getElementById('pause-deaths');
        const playerNameInput = document.getElementById('player-name');
        const saveEndButton = document.getElementById('save-end-button');
        const continueButton = document.getElementById('continue-button');
        const restartButton = document.getElementById('restart-button');
        const leaderboardScreen = document.getElementById('leaderboard-screen');
        const leaderboardEntriesElement = document.getElementById('leaderboard-entries');
        const newGameButton = document.getElementById('new-game-button');
        
        // Audio loading screen elements
        const audioLoadingScreen = document.getElementById('game-loading-screen');
        const audioLoadingBar = document.getElementById('game-loading-bar');
        const audioLoadingStatus = document.getElementById('game-loading-status');
        const startGameButton = document.getElementById('start-game-button');
        
        // Initialize the audio system
        if (AudioManager.init()) {
            // Start preloading audio
            AudioManager.preloadAudio(
                // Progress callback
                function(progress) {
                    audioLoadingBar.style.width = `${progress}%`;
                    audioLoadingStatus.textContent = `Loading game: ${Math.floor(progress)}%`;
                },
                // Complete callback
                function() {
                    audioLoadingStatus.textContent = 'Game loaded! Click Start to begin';
                    startGameButton.disabled = false;
                    
                    // Add shine effect to button
                    startGameButton.style.boxShadow = '0 0 10px #ff5500';
                }
            );
        } else {
            // Fallback if audio system fails to initialize
            audioLoadingStatus.textContent = 'Audio system unavailable. Click Start to play without sound.';
            startGameButton.disabled = false;
        }
        
        // Start button event listener
        startGameButton.addEventListener('click', function() {
            // Resume audio context (needed for browsers that require user interaction)
            AudioManager.startAudioContext();
            
            // Hide loading screen
            audioLoadingScreen.style.display = 'none';
            
            // Start the game with initial draw
            initialDraw();
        });
        
        // Canvas sizing and responsive behavior
        let baseCanvasWidth = 800;  // Original design width
        let baseCanvasHeight = 500; // Original design height
        let aspectRatio = baseCanvasHeight / baseCanvasWidth;
        
        // Function to resize the game canvas based on window size
        function resizeGameCanvas() {
            const windowWidth = window.innerWidth;
            const containerWidth = windowWidth - 200; // 100px on each side
            
            // Set max width to prevent the game from becoming too large on big screens
            const maxWidth = 1600;
            const effectiveWidth = Math.min(containerWidth, maxWidth);
            
            // Calculate height based on the original aspect ratio
            const effectiveHeight = effectiveWidth * aspectRatio;
            
            // Update canvas dimensions
            canvas.width = effectiveWidth;
            canvas.height = effectiveHeight;
            
            // Update camera dimensions
            if (camera) {
                camera.width = effectiveWidth;
                camera.height = effectiveHeight;
            }
            
            // Redraw the game if it's paused
            if (gameStarted && isPaused) {
                drawPausedGameState();
            } else if (!gameStarted) {
                initialDraw();
            }
        }
        
        // Call resize function when window is resized
        window.addEventListener('resize', resizeGameCanvas);
        
        // Call it once on page load
        window.addEventListener('load', resizeGameCanvas);
        
        // Function to draw the game state when paused (to ensure it looks correct after resize)
        function drawPausedGameState() {
            // This is similar to the drawing parts of the gameLoop but without updates
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#001133');
            bgGradient.addColorStop(1, '#330011');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw game elements with camera offset
            ctx.save();
            
            // Draw platforms (only those in view)
            for (const platform of platforms) {
                if (platform.x + platform.width >= camera.x - 50 && platform.x <= camera.x + camera.width + 50) {
                    platform.draw(ctx, camera.x);
                }
            }
            
            // Draw lava (only those in view)
            for (const lava of lavas) {
                if (lava.x + lava.width >= camera.x - 50 && lava.x <= camera.x + camera.width + 50) {
                    lava.draw(ctx, camera.x);
                }
            }
            
            // Draw lava bubbles
            for (const bubble of lavaBubbles) {
                if (Math.abs(bubble.x - (camera.x + camera.width/2)) < camera.width) {
                    bubble.draw(ctx, camera.x);
                }
            }
            
            // Draw goal
            if (goal) {
                goal.draw(ctx, camera.x);
            }
            
            // Draw player (with camera offset)
            const playerScreenPos = camera.apply(player.x, player.y);
            player.draw();
            
            ctx.restore();
            
            // Draw level info
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(canvas.width - 150, 10, 140, 30);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`Level: ${level}`, canvas.width - 20, 32);
        }
        
        // Leaderboard
        let leaderboard = [];
        const MAX_LEADERBOARD_ENTRIES = 5;
        
        // Load leaderboard from local storage
        function loadLeaderboard() {
            const storedLeaderboard = localStorage.getItem('lavaParkourLeaderboard');
            if (storedLeaderboard) {
                try {
                    leaderboard = JSON.parse(storedLeaderboard);
                } catch (e) {
                    console.error('Error loading leaderboard from local storage:', e);
                    leaderboard = [];
                }
            }
            updateLeaderboardDisplay();
        }
        
        // Save leaderboard to local storage
        function saveLeaderboard() {
            try {
                localStorage.setItem('lavaParkourLeaderboard', JSON.stringify(leaderboard));
            } catch (e) {
                console.error('Error saving leaderboard to local storage:', e);
            }
        }
        
        // Update leaderboard display
        function updateLeaderboardDisplay() {
            // Clear existing entries
            leaderboardEntriesElement.innerHTML = '';
            
            // Sort leaderboard by level (desc) then deaths (asc)
            leaderboard.sort((a, b) => {
                if (b.level !== a.level) {
                    return b.level - a.level; // Higher level first
                }
                return a.deaths - b.deaths; // Fewer deaths first
            });
            
            // Create a table for the leaderboard
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.marginBottom = '15px';
            
            // Create table header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            const headers = ['Rank', 'Player', 'Level', 'Deaths'];
            headers.forEach(headerText => {
                const header = document.createElement('th');
                header.textContent = headerText;
                header.style.borderBottom = '2px solid #ff5500';
                header.style.padding = '5px 10px';
                header.style.textAlign = headerText === 'Player' ? 'left' : 'center';
                headerRow.appendChild(header);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create table body
            const tbody = document.createElement('tbody');
            
            // Display top entries
            for (let i = 0; i < Math.min(leaderboard.length, MAX_LEADERBOARD_ENTRIES); i++) {
                const entry = leaderboard[i];
                const row = document.createElement('tr');
                
                // Rank cell
                const rankCell = document.createElement('td');
                rankCell.textContent = `${i + 1}`;
                rankCell.style.color = '#ff8800';
                rankCell.style.textAlign = 'center';
                rankCell.style.padding = '8px 10px';
                rankCell.style.borderBottom = '1px solid #333';
                rankCell.style.fontWeight = 'bold';
                
                // Name cell
                const nameCell = document.createElement('td');
                nameCell.textContent = entry.name;
                nameCell.style.padding = '8px 10px';
                nameCell.style.borderBottom = '1px solid #333';
                nameCell.style.maxWidth = '150px';
                nameCell.style.overflow = 'hidden';
                nameCell.style.textOverflow = 'ellipsis';
                nameCell.style.whiteSpace = 'nowrap';
                
                // Level cell
                const levelCell = document.createElement('td');
                levelCell.textContent = entry.level;
                levelCell.style.color = '#00ffff';
                levelCell.style.textAlign = 'center';
                levelCell.style.padding = '8px 10px';
                levelCell.style.borderBottom = '1px solid #333';
                levelCell.style.fontWeight = 'bold';
                
                // Deaths cell
                const deathsCell = document.createElement('td');
                deathsCell.textContent = entry.deaths;
                deathsCell.style.textAlign = 'center';
                deathsCell.style.padding = '8px 10px';
                deathsCell.style.borderBottom = '1px solid #333';
                
                row.appendChild(rankCell);
                row.appendChild(nameCell);
                row.appendChild(levelCell);
                row.appendChild(deathsCell);
                
                tbody.appendChild(row);
            }
            
            table.appendChild(tbody);
            leaderboardEntriesElement.appendChild(table);
            
            // Show "No scores yet" if leaderboard is empty
            if (leaderboard.length === 0) {
                const emptyElement = document.createElement('div');
                emptyElement.textContent = 'No scores yet. Be the first!';
                emptyElement.style.textAlign = 'center';
                emptyElement.style.margin = '30px 0';
                emptyElement.style.fontStyle = 'italic';
                emptyElement.style.color = '#888';
                leaderboardEntriesElement.appendChild(emptyElement);
            }
        }
        
        // Check if current run qualifies for leaderboard
        function checkForHighScore() {
            // If leaderboard isn't full yet, this run qualifies
            if (leaderboard.length < MAX_LEADERBOARD_ENTRIES) {
                return true;
            }
            
            // Sort to find lowest score on board
            leaderboard.sort((a, b) => {
                if (b.level !== a.level) {
                    return b.level - a.level; // Higher level first
                }
                return a.deaths - b.deaths; // Fewer deaths first
            });
            
            // Get the lowest entry
            const lowestEntry = leaderboard[leaderboard.length - 1];
            
            // Compare with current run
            return (level > lowestEntry.level || 
                   (level === lowestEntry.level && deaths < lowestEntry.deaths));
        }
        
        // Add new entry to leaderboard
        function addLeaderboardEntry(name, level, deaths) {
            leaderboard.push({
                name: name || 'Anonymous',
                level: level,
                deaths: deaths,
                timestamp: Date.now()
            });
            
            // Sort and trim
            leaderboard.sort((a, b) => {
                if (b.level !== a.level) {
                    return b.level - a.level; // Higher level first
                }
                return a.deaths - b.deaths; // Fewer deaths first
            });
            
            // Keep only the top scores
            if (leaderboard.length > MAX_LEADERBOARD_ENTRIES) {
                leaderboard = leaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
            }
            
            // Save and update display
            saveLeaderboard();
            updateLeaderboardDisplay();
        }
        
        let deaths = 0;
        let animationId = null;
        let gameStarted = false;
        let isPaused = false;
        let level = 1;
        let maxJumpGap = 180; // Increased maximum gap that player can jump
        let lastTime = 0; // For delta time calculation
        let runEnded = false; // Flag to prevent double high score prompts
        
        // Camera system
        const camera = {
            x: 0,
            y: 0,
            width: canvas.width || baseCanvasWidth,
            height: canvas.height || baseCanvasHeight,
            followPlayer: function(playerX, playerY) {
                // Calculate target camera position (center on player)
                const targetX = playerX - this.width / 2;
                
                // Smooth camera movement
                this.x += (targetX - this.x) * 0.1;
                
                // Clamp camera to prevent showing empty space
                this.x = Math.max(0, this.x);
            },
            apply: function(x, y) {
                // Convert world coordinates to screen coordinates
                return {
                    x: x - this.x,
                    y: y
                };
            }
        };
        
        // Player object
        const player = {
            x: 50,
            y: 300,
            width: 30,
            height: 30,
            speed: 20, // Reduced from 25 to 20 (20% reduction)
            velX: 0,
            velY: 0,
            jumping: false,
            doubleJump: false,
            grounded: false,
            wasGrounded: false, // Track previous grounded state for landing sound
            currentPlatform: null, // Track the platform player is on
            color: '#333333', // Dark gray for ninja
            draw() {
                // Base ninja body (dark gray)
                const screenPos = camera.apply(this.x, this.y);
                
                ctx.fillStyle = this.color;
                ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);
                
                // Ninja mask (darker area over most of face)
                ctx.fillStyle = '#222222'; 
                ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height * 0.7);
                
                // Red ninja headband
                ctx.fillStyle = '#cc0000';
                ctx.fillRect(screenPos.x, screenPos.y + 6, this.width, 5);
                
                // Headband knot on the side
                ctx.fillStyle = '#cc0000';
                ctx.fillRect(screenPos.x + this.width - 5, screenPos.y + 5, 8, 3);
                ctx.fillRect(screenPos.x + this.width - 3, screenPos.y + 8, 6, 3);
                
                // Ninja eyes (white slits in mask)
                ctx.fillStyle = 'white';
                ctx.fillRect(screenPos.x + 7, screenPos.y + 12, 5, 2); // Left eye
                ctx.fillRect(screenPos.x + 18, screenPos.y + 12, 5, 2); // Right eye
                
                // Add throwing star in hand when moving
                if (Math.abs(this.velX) > 0.5) {
                    ctx.fillStyle = '#aaaaaa';
                    ctx.beginPath();
                    const starX = screenPos.x + (this.velX > 0 ? this.width - 2 : -6);
                    const starY = screenPos.y + this.height - 10;
                    const starSize = 6;
                    
                    // Draw a simple shuriken/throwing star
                    ctx.moveTo(starX, starY - starSize/2);
                    ctx.lineTo(starX + starSize/2, starY);
                    ctx.lineTo(starX, starY + starSize/2);
                    ctx.lineTo(starX - starSize/2, starY);
                    ctx.fill();
                }
            }
        };
        
        // Platform class
        class Platform {
            constructor(x, y, width, height, color = '#4CAF50', isMoving = false, moveType = 'horizontal', moveRange = 100) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.isMoving = isMoving;
                this.moveType = moveType; // 'horizontal' or 'vertical'
                this.direction = 1;
                this.originalX = x;
                this.originalY = y;
                this.moveRange = moveRange;
                this.baseSpeed = (1.0 + (level * 0.1)) * gameSpeedMultiplier; // Platforms move faster at higher levels, affected by game speed
            }
            
            update(deltaTime = 1) {
                if (this.isMoving) {
                    const adjustedSpeed = this.baseSpeed * deltaTime;
                    
                    if (this.moveType === 'horizontal') {
                        this.x += this.direction * adjustedSpeed;
                        
                        if (this.x > this.originalX + this.moveRange) {
                            this.direction = -1;
                        } else if (this.x < this.originalX - this.moveRange) {
                            this.direction = 1;
                        }
                    } else if (this.moveType === 'vertical') {
                        // Reduce vertical movement speed (it's harder for players)
                        const verticalSpeed = adjustedSpeed * 0.6;
                        this.y += this.direction * verticalSpeed;
                        
                        // Use smaller range for vertical movement
                        if (this.y > this.originalY + 30) {
                            this.direction = -1;
                        } else if (this.y < this.originalY - 30) {
                            this.direction = 1;
                        }
                    }
                }
            }
            
            draw(ctx, cameraX) {
                const screenPos = {
                    x: this.x - cameraX,
                    y: this.y
                };
                
                ctx.fillStyle = this.color;
                ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);
            }
        }
        
        // Lava class
        class Lava {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.particleTimer = 0;
                this.particles = [];
                this.bubbleTimer = 0;
            }
            
            update(deltaTime = 1) {
                // Add lava particles periodically
                this.particleTimer += deltaTime;
                if (this.particleTimer > 5) {
                    this.particleTimer = 0;
                    for (let i = 0; i < 3; i++) {
                        this.particles.push({
                            x: this.x + Math.random() * this.width,
                            y: this.y,
                            size: Math.random() * 4 + 2,
                            speedY: -(Math.random() * 3 + 1),
                            speedX: Math.random() * 2 - 1,
                            life: Math.random() * 30 + 20
                        });
                    }
                }
                
                // Occasionally play bubble sound
                this.bubbleTimer += deltaTime;
                if (this.bubbleTimer > 60 && Math.random() < 0.1) {
                    this.bubbleTimer = 0;
                    
                    // Only play if player is close enough to hear it
                    const playerDistX = Math.abs(player.x - (this.x + this.width/2));
                    if (playerDistX < 500) {
                        AudioManager.playSfx('lavaBubble');
                    }
                }
                
                // Update particles
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    p.y += p.speedY * deltaTime;
                    p.x += p.speedX * deltaTime;
                    p.life -= deltaTime;
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                        i--;
                    }
                }
            }
            
            draw(ctx, cameraX) {
                const screenX = this.x - cameraX;
                
                // Draw main lava body
                const gradient = ctx.createLinearGradient(screenX, this.y, screenX, this.y + this.height);
                gradient.addColorStop(0, '#FF5500');
                gradient.addColorStop(1, '#CC0000');
                ctx.fillStyle = gradient;
                ctx.fillRect(screenX, this.y, this.width, this.height);
                
                // Draw wavy lava top
                ctx.beginPath();
                ctx.moveTo(screenX, this.y);
                
                const waveHeight = 5;
                const segments = this.width / 20;
                const time = Date.now() / 500;
                
                for (let i = 0; i <= segments; i++) {
                    const x = screenX + (i / segments) * this.width;
                    const y = this.y + Math.sin(i * 0.5 + time) * waveHeight;
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(screenX + this.width, this.y);
                ctx.fillStyle = '#FF8800';
                ctx.fill();
                
                // Draw particles
                for (const p of this.particles) {
                    const particleX = p.x - cameraX;
                    ctx.fillStyle = `rgba(255, ${Math.floor(Math.random() * 100 + 100)}, 0, ${p.life / 50})`;
                    ctx.beginPath();
                    ctx.arc(particleX, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Exploding Lava Bubble class
        class LavaBubble {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.baseSize = size;
                this.active = true;
                this.exploding = false;
                this.explosionRadius = 0;
                this.maxExplosionRadius = 80;
                this.explosionDuration = 0;
                this.maxExplosionDuration = 30;
                this.cooldown = 0;
                this.maxCooldown = 120;
                this.warningPulse = 0;
                this.warningDirection = 1;
                this.triggerDistance = 150;
                this.warningPlayedAt = 0; // To avoid sound spamming
                this.hasExploded = false; // Track if explosion sound played
            }
            
            update(deltaTime, playerX, playerY) {
                // Calculate distance to player
                const dx = this.x - playerX;
                const dy = this.y - playerY;
                const distanceToPlayer = Math.sqrt(dx * dx + dy * dy);
                
                if (this.exploding) {
                    // Handle explosion animation
                    this.explosionDuration += deltaTime;
                    this.explosionRadius = (this.explosionDuration / this.maxExplosionDuration) * this.maxExplosionRadius;
                    
                    // Play explosion sound once
                    if (!this.hasExploded) {
                        AudioManager.playSfx('lavaBubble');
                        this.hasExploded = true;
                    }
                    
                    if (this.explosionDuration >= this.maxExplosionDuration) {
                        this.exploding = false;
                        this.active = false;
                        this.cooldown = this.maxCooldown;
                        this.hasExploded = false;
                    }
                } else if (!this.active) {
                    // Handle cooldown
                    this.cooldown -= deltaTime;
                    if (this.cooldown <= 0) {
                        this.active = true;
                        this.size = this.baseSize;
                    }
                } else if (distanceToPlayer < this.triggerDistance) {
                    // Player is close, start warning pulse
                    this.warningPulse += 0.1 * this.warningDirection * deltaTime;
                    
                    if (this.warningPulse >= 1) {
                        this.warningPulse = 1;
                        this.warningDirection = -1;
                    } else if (this.warningPulse <= 0) {
                        this.warningPulse = 0;
                        this.warningDirection = 1;
                    }
                    
                    // Play warning sound occasionally
                    if (this.warningPulse > 0.8 && Date.now() - this.warningPlayedAt > 1000) {
                        AudioManager.playSfx('lavaBubble');
                        this.warningPlayedAt = Date.now();
                    }
                    
                    // If player gets very close, explode!
                    if (distanceToPlayer < this.triggerDistance * 0.5) {
                        this.exploding = true;
                        this.explosionDuration = 0;
                        this.explosionRadius = 0;
                    }
                }
            }
            
            draw(ctx, cameraX) {
                if (!this.active && !this.exploding) return;
                
                const screenX = this.x - cameraX;
                
                if (this.exploding) {
                    // Draw explosion
                    const gradient = ctx.createRadialGradient(
                        screenX, this.y, 0,
                        screenX, this.y, this.explosionRadius
                    );
                    
                    gradient.addColorStop(0, 'rgba(255, 200, 50, 0.9)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 20, 0.7)');
                    gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, this.y, this.explosionRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw explosion particles
                    const particleCount = 8;
                    const angleStep = (Math.PI * 2) / particleCount;
                    
                    ctx.fillStyle = '#FFAA00';
                    for (let i = 0; i < particleCount; i++) {
                        const angle = i * angleStep + (Date.now() / 200);
                        const dist = this.explosionRadius * 0.7;
                        const x = screenX + Math.cos(angle) * dist;
                        const y = this.y + Math.sin(angle) * dist;
                        
                        const size = 3 + Math.sin(Date.now() / 100 + i) * 2;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Draw active lava bubble
                    const pulseSize = this.warningPulse > 0 ? 
                        this.size * (1 + this.warningPulse * 0.3) : this.size;
                    
                    // Base lava bubble
                    ctx.fillStyle = '#FF5500';
                    ctx.beginPath();
                    ctx.arc(screenX, this.y, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner glow
                    const innerGradient = ctx.createRadialGradient(
                        screenX, this.y, 0,
                        screenX, this.y, pulseSize
                    );
                    
                    innerGradient.addColorStop(0, 'rgba(255, 255, 100, 0.7)');
                    innerGradient.addColorStop(0.6, 'rgba(255, 150, 50, 0.3)');
                    innerGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    
                    ctx.fillStyle = innerGradient;
                    ctx.beginPath();
                    ctx.arc(screenX, this.y, pulseSize * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Warning effect when pulsing
                    if (this.warningPulse > 0.5) {
                        ctx.strokeStyle = `rgba(255, 255, 100, ${this.warningPulse})`;
                        ctx.lineWidth = 2 + this.warningPulse * 2;
                        ctx.beginPath();
                        ctx.arc(screenX, this.y, pulseSize + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }
            
            checkCollision(playerX, playerY, playerWidth, playerHeight) {
                if (!this.active && !this.exploding) return false;
                
                // For regular state, check circle collision with player rectangle
                if (!this.exploding) {
                    // Find closest point on rectangle to circle center
                    const closestX = Math.max(playerX, Math.min(this.x, playerX + playerWidth));
                    const closestY = Math.max(playerY, Math.min(this.y, playerY + playerHeight));
                    
                    // Calculate distance between closest point and circle center
                    const distX = this.x - closestX;
                    const distY = this.y - closestY;
                    const distance = Math.sqrt(distX * distX + distY * distY);
                    
                    return distance < this.size;
                } else {
                    // For explosion, check if player is within explosion radius
                    const playerCenterX = playerX + playerWidth / 2;
                    const playerCenterY = playerY + playerHeight / 2;
                    
                    const dx = this.x - playerCenterX;
                    const dy = this.y - playerCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    return distance < this.explosionRadius * 0.8;
                }
            }
        }
        
        // Goal class
        class Goal {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.pulseValue = 0;
                this.pulseDirection = 1;
            }
            
            update(deltaTime = 1) {
                // Create pulsing effect with clamping to prevent errors
                this.pulseValue += 0.05 * this.pulseDirection * Math.min(deltaTime, 2);
                if (this.pulseValue > 1) {
                    this.pulseValue = 1;
                    this.pulseDirection = -1;
                } else if (this.pulseValue < 0) {
                    this.pulseValue = 0;
                    this.pulseDirection = 1;
                }
            }
            
            draw(ctx, cameraX) {
                const screenPos = {
                    x: this.x - cameraX,
                    y: this.y
                };
                
                // Only draw if on screen
                if (screenPos.x + this.width >= 0 && screenPos.x <= camera.width) {
                    // Create a glowing portal effect
                    const pulseIntensity = 0.5 + (this.pulseValue || 0) * 0.5;
                    
                    // Ensure values are finite and within reasonable ranges
                    const centerX = screenPos.x + this.width / 2;
                    const centerY = screenPos.y + this.height / 2;
                    const innerRadius = 0;
                    const outerRadius = Math.min(20 * pulseIntensity + this.width / 2, 100);
                    
                    // Safety check for valid values
                    if (isFinite(centerX) && isFinite(centerY) && 
                        isFinite(innerRadius) && isFinite(outerRadius) &&
                        outerRadius > innerRadius) {
                        // Draw outer glow
                        try {
                            const gradient = ctx.createRadialGradient(
                                centerX, centerY, innerRadius,
                                centerX, centerY, outerRadius
                            );
                            gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                            gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.fillRect(
                                centerX - outerRadius, 
                                centerY - outerRadius,
                                outerRadius * 2,
                                outerRadius * 2
                            );
                        } catch (e) {
                            // Fallback if gradient fails
                            ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                            ctx.fillRect(screenPos.x - 10, screenPos.y - 10, this.width + 20, this.height + 20);
                        }
                    } else {
                        // Fallback for invalid values
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                        ctx.fillRect(screenPos.x - 10, screenPos.y - 10, this.width + 20, this.height + 20);
                    }
                    
                    // Draw portal
                    ctx.fillStyle = '#00FFFF';
                    ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);
                    
                    // Draw swirl effect
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const time = Date.now() / 1000;
                    
                    for (let i = 0; i < 10; i++) {
                        const angle = (i / 10) * Math.PI * 2 + time;
                        const radius = (i / 10) * (this.width / 2 - 5);
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                }
            }
        }
        
        // Game elements
        let platforms = [];
        let lavas = [];
        let lavaBubbles = [];
        let goal = null;
        
        // Procedural level generation
        function generateLevel(level) {
            platforms = [];
            lavas = [];
            lavaBubbles = [];
            goal = null;
            
            // Calculate difficulty parameters based on level
            const difficulty = Math.min(level * 0.15, 0.8); // 0.0 to 0.8, maxes out at level 5 (more gradual)
            const extraDifficulty = Math.max(0, level - 5) * 0.05; // Additional scaling after level 5 (more gradual)
            
            // Adjusted platform parameters for increased difficulty
            const minPlatformWidth = Math.max(40, 90 - (level * 4)); // Platforms get narrower more quickly
            const maxPlatformWidth = Math.max(70, 130 - (level * 4)); 
            const minGap = 70 + (level * 4); // Gaps get wider more quickly
            const maxGap = 120 + (level * 7); // Increased maximum gap size
            
            // Adjust the player's jump ability based on level
            const effectiveJumpGap = maxJumpGap + (level * 5); // Player can jump further at higher levels
            
            // Moving platform parameters
            const movingPlatformChance = Math.min(0.05 + (level * 0.04), 0.5); // More gradual increase in moving platforms
            const verticalMovingChance = Math.min(0.05 + (level * 0.02), 0.3); // Fewer vertical platforms (they're harder)
            
            // Always add starting ground platform
            platforms.push(new Platform(0, 400, 200, 100));
            
            // Make the level longer for higher levels
            const levelLengthMultiplier = 1 + Math.min(level * 0.2, 2.0); // Up to 3x longer at level 10+
            const goalX = 2000 * levelLengthMultiplier; // Much longer parkour course (increased from 1200 to 2000)
            const goalY = 200 + Math.random() * 100; // Random goal height
            
            // Generate path of platforms to the goal
            let currentX = 200; // Start after the ground platform
            let currentY = 400; // Start at ground level
            let lastY = currentY; // Track the last platform Y position
            
            // Track consecutive difficult jumps to prevent impossible sequences
            let difficultJumpsInARow = 0;
            
            while (currentX < goalX) {
                // Decide platform width based on position (wider platforms near the beginning)
                const progressFactor = Math.min(currentX / goalX, 1); // 0-1 progress through level
                const platformWidth = minPlatformWidth + Math.random() * (maxPlatformWidth - minPlatformWidth);
                
                // Decide if moving platform (more likely later in the level)
                const isMoving = Math.random() < (movingPlatformChance * progressFactor * 1.5);
                const moveType = Math.random() < verticalMovingChance ? 'vertical' : 'horizontal';
                
                // More controlled movement ranges based on type
                const moveRange = moveType === 'horizontal' ? 
                    40 + Math.random() * 80 : // Horizontal can move more
                    20 + Math.random() * 40;  // Vertical moves less
                
                // Decide platform height change
                let heightChange;
                if (currentY > goalY && currentX > goalX * 0.6) {
                    // If we're past 60% and need to go up to reach the goal, bias upward
                    heightChange = -(20 + Math.random() * 60);
                } else if (difficultJumpsInARow >= 2) {
                    // After 2 difficult jumps, make an easier one
                    heightChange = Math.random() * 30 - 15; // Small change up or down
                    difficultJumpsInARow = 0;
                } else {
                    // Normal height change
                    heightChange = Math.random() < 0.6 ? 
                        -(Math.random() * 60) : // 60% chance to go up (typical platformer)
                        Math.random() * 30;     // 40% chance to go down (a bit)
                }
                
                // Calculate new Y position with bounds
                const targetY = currentY + heightChange;
                currentY = Math.max(150, Math.min(380, targetY));
                
                // Calculate height difference from last platform
                const heightDiff = Math.abs(currentY - lastY);
                
                // Decide gap size - smaller gaps for big height differences
                let gapSize;
                if (heightDiff > 60) {
                    // Big height difference - smaller gap
                    gapSize = minGap + Math.random() * (minGap * 0.5);
                    difficultJumpsInARow++;
                } else if (heightDiff > 30) {
                    // Medium height difference - medium gap
                    gapSize = minGap + Math.random() * (maxGap - minGap) * 0.7;
                    if (gapSize > effectiveJumpGap * 0.7) difficultJumpsInARow++;
                } else {
                    // Small height difference - can have wider gaps
                    gapSize = minGap + Math.random() * (maxGap - minGap);
                    if (gapSize > effectiveJumpGap * 0.8) difficultJumpsInARow++;
                }
                
                // Safety check - ensure gap isn't too large based on height difference
                if (heightDiff > 40) {
                    gapSize = Math.min(gapSize, effectiveJumpGap - heightDiff * 0.8);
                }
                
                // Add platform
                const platformPosX = currentX + gapSize;
                const platformPosY = currentY;
                
                // Platform color depends on type
                const platformColor = isMoving ? '#FF9800' : '#4CAF50';
                
                // Add stepping stones for very large gaps
                if (gapSize > maxGap && !isMoving && heightDiff < 30) {
                    // Add a small stepping stone in the middle
                    const steppingStoneX = currentX + (gapSize / 2) - 15;
                    const steppingStoneWidth = 30;
                    
                    platforms.push(new Platform(
                        steppingStoneX, 
                        (currentY + lastY) / 2, // mid-height
                        steppingStoneWidth, 
                        15, 
                        '#4CAF50',
                        false,
                        'horizontal',
                        0
                    ));
                }
                
                platforms.push(new Platform(
                    platformPosX, 
                    platformPosY, 
                    platformWidth, 
                    20, 
                    platformColor,
                    isMoving,
                    moveType,
                    moveRange
                ));
                
                // Move to next platform position
                currentX = platformPosX + platformWidth;
                lastY = platformPosY; // Update the last platform Y position
                
                // Occasionally add a bonus platform nearby
                if (Math.random() < 0.15 && !isMoving) {
                    const bonusPlatformX = platformPosX + platformWidth + 20 + Math.random() * 30;
                    const bonusPlatformY = platformPosY + (Math.random() < 0.5 ? -40 : 40);
                    
                    if (bonusPlatformY > 150 && bonusPlatformY < 380) {
                        platforms.push(new Platform(
                            bonusPlatformX,
                            bonusPlatformY,
                            30 + Math.random() * 40,
                            15,
                            '#4CAF50',
                            false,
                            'horizontal',
                            0
                        ));
                    }
                }
                
                // Add exploding lava bubbles with increasing frequency based on level
                if (Math.random() < 0.1 + (level * 0.02) && currentX > 400) {
                    // Place exploding lava in gaps between platforms
                    const bubbleX = currentX + (gapSize / 2);
                    
                    // Randomize Y position - sometimes in the jump path, sometimes above/below
                    let yOffset = 0;
                    const positionType = Math.random();
                    
                    if (positionType < 0.5) {
                        // In the jump path
                        yOffset = Math.random() * 60 - 30;
                    } else if (positionType < 0.75) {
                        // Above
                        yOffset = -50 - Math.random() * 50;
                    } else {
                        // Below
                        yOffset = 50 + Math.random() * 50;
                    }
                    
                    const bubbleY = (currentY + lastY) / 2 + yOffset;
                    
                    // Don't place too high or too low
                    if (bubbleY > 120 && bubbleY < 400) {
                        // Size increases with level
                        const size = 10 + Math.min(level, 10);
                        lavaBubbles.push(new LavaBubble(bubbleX, bubbleY, size));
                    }
                }
            }
            
            // Add approach platforms to the goal
            const goalApproachX = goalX - 200;
            const goalApproachY = goalY + 20;
            
            // Add a series of platforms leading to the goal
            platforms.push(new Platform(goalApproachX, goalApproachY, 60, 20));
            platforms.push(new Platform(goalApproachX + 100, goalApproachY - 30, 60, 20));
            
            // Add final goal platform
            platforms.push(new Platform(goalX - 20, goalY, 70, 20));
            platforms.push(new Platform(goalX, goalY - 50, 100, 300));
            
            // Add lava at the bottom
            lavas.push(new Lava(0, 450, goalX + 500, 50));
            
            // Add random lava pits (more at higher levels, but not too many)
            const lavaPitCount = Math.min(Math.floor(level / 2), 8);
            const safeZoneStart = 200; // Don't put lava pits too close to start
            const safeZoneEnd = goalX - 300; // Don't put lava pits too close to goal
            const availableSpace = safeZoneEnd - safeZoneStart;
            
            for (let i = 0; i < lavaPitCount; i++) {
                // Distribute lava pits more evenly
                const lavaX = safeZoneStart + (i / lavaPitCount) * availableSpace + (Math.random() * 100 - 50);
                const lavaWidth = 30 + Math.random() * 50;
                const lavaY = 400 - Math.random() * 50;
                lavas.push(new Lava(lavaX, lavaY, lavaWidth, 100));
            }
            
            // Add goal
            goal = new Goal(goalX + 30, goalY - 90, 40, 40);
        }
        
        // Initialize level
        generateLevel(level);
        
        // Keyboard controls
        const keys = {};
        let canDoubleJump = true;
        let jumpKeyPressed = false;
        
        document.addEventListener('keydown', function(e) {
            // Start game on any key press
            if (!gameStarted && audioLoadingScreen.style.display === 'none') {
                gameStarted = true;
                isPaused = false;
                lastTime = 0; // Reset time
                runEnded = false; // Reset run ended flag
                
                // Start audio context
                AudioManager.startAudioContext();
                
                // Start background music
                AudioManager.startMusic();
                
                // Reset player position
                player.x = 50;
                player.y = 300;
                player.velX = 0;
                player.velY = 0;
                
                // Start the game loop
                requestAnimationFrame(gameLoop);
            }
            
            keys[e.key] = true;
            
            // Jump logic
            if ((e.key === ' ' || e.key === 'w' || e.key === 'ArrowUp') && !jumpKeyPressed) {
                jumpKeyPressed = true;
                
                if (!player.jumping) {
                    player.jumping = true;
                    player.grounded = false;
                    player.velY = -12 * gameSpeedMultiplier;
                    player.currentPlatform = null; // Clear platform reference when jumping
                    
                    // Play jump sound
                    AudioManager.playSfx('jump');
                } else if (canDoubleJump) {
                    canDoubleJump = false;
                    player.velY = -10 * gameSpeedMultiplier;
                    
                    // Play double jump sound
                    AudioManager.playSfx('doubleJump');
                }
            }
            
            // Pause game with Escape or P
            if (e.key === 'Escape' || e.key === 'p') {
                if (gameStarted && gameOverScreen.style.display !== 'block' && levelUpScreen.style.display !== 'block') {
                    isPaused = true;
                    
                    // Play menu sound
                    AudioManager.playSfx('menuClick');
                    
                    // Update pause menu with current stats
                    pauseLevelDisplay.textContent = level;
                    pauseDeathsDisplay.textContent = deaths;
                    
                    // Clear any existing name
                    playerNameInput.value = '';
                    
                    // Show pause menu
                    pauseMenu.style.display = 'block';
                }
            }
        });
        
        document.addEventListener('keyup', function(e) {
            keys[e.key] = false;
            
            if (e.key === ' ' || e.key === 'w' || e.key === 'ArrowUp') {
                jumpKeyPressed = false;
            }
        });
        
        // Add sound effects to button clicks
        const buttons = document.querySelectorAll('button');
        buttons.forEach(button => {
            button.addEventListener('click', function() {
                AudioManager.playSfx('menuClick');
            });
        });
        
        // Collision detection
        function checkCollisions() {
            // Save previous grounded state
            player.wasGrounded = player.grounded;
            player.grounded = false;
            
            // Check platform collisions
            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                
                // Check if player is on top of the platform
                const playerBottom = player.y + player.height;
                const platformTop = platform.y;
                
                if (playerBottom >= platformTop && 
                    player.y < platform.y + platform.height && 
                    player.x + player.width > platform.x && 
                    player.x < platform.x + platform.width) {
                    
                    // Landing on platform
                    if (player.velY > 0 && playerBottom - player.velY <= platformTop + 5) {
                        player.y = platform.y - player.height;
                        player.velY = 0;
                        player.grounded = true;
                        player.jumping = false;
                        player.currentPlatform = platform; // Store reference to the platform
                        canDoubleJump = true;
                        
                        // Play landing sound when transitioning from not grounded to grounded,
// but only if player was actually falling (positive velocity)
if (!player.wasGrounded && player.grounded && player.velY > 2) {
    AudioManager.playSfx('landing');
}
                    } 
                    // Hit platform from below
                    else if (player.velY < 0 && player.y >= platform.y + platform.height - 5) {
                        player.velY = 0;
                        player.y = platform.y + platform.height;
                    }
                    // Left side collision
                    else if (player.velX > 0 && player.x + player.width - player.velX <= platform.x + 5) {
                        player.velX = 0;
                        player.x = platform.x - player.width;
                    }
                    // Right side collision
                    else if (player.velX < 0 && player.x - player.velX >= platform.x + platform.width - 5) {
                        player.velX = 0;
                        player.x = platform.x + platform.width;
                    }
                }
            }
            
            // Check lava collisions (game over)
            for (let i = 0; i < lavas.length; i++) {
                const lava = lavas[i];
                
                if (player.x + player.width > lava.x && 
                    player.x < lava.x + lava.width && 
                    player.y + player.height > lava.y) {
                    restartLevel();
                    break;
                }
            }
            
            // Check lava bubble collisions
            for (let i = 0; i < lavaBubbles.length; i++) {
                const bubble = lavaBubbles[i];
                
                if (bubble.checkCollision(player.x, player.y, player.width, player.height)) {
                    restartLevel();
                    break;
                }
            }
            
            // Check goal collision (victory)
            if (goal &&
                player.x + player.width > goal.x && 
                player.x < goal.x + goal.width && 
                player.y + player.height > goal.y &&
                player.y < goal.y + goal.height) {
                levelComplete();
            }
            
            // Check if player falls off the screen
            if (player.y > canvas.height) {
                restartLevel();
            }
        }
        
        // Game loop with delta time
        function gameLoop(timestamp) {
            // Initialize lastTime on first call
            if (!lastTime) lastTime = timestamp;
            const deltaTime = Math.min((timestamp - lastTime) / 16.67, 3); // Normalize to ~60fps, cap at 3x
            lastTime = timestamp;
            
            // Check if game is paused
            if (isPaused) {
                // If paused, just request next frame but don't update
                animationId = requestAnimationFrame(gameLoop);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#001133');
            bgGradient.addColorStop(1, '#330011');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update camera to follow player
            camera.followPlayer(player.x, player.y);
            
            // First - Update moving platforms and always check if player is on one
            let playerOnMovingPlatform = false;
            
            for (const platform of platforms) {
                if (platform.isMoving) {
                    // Store platform's previous position
                    const prevX = platform.x;
                    const prevY = platform.y;
                    
                    // Update platform position
                    platform.update(deltaTime);
                    
                    // Get platform movement delta
                    const dx = platform.x - prevX;
                    const dy = platform.y - prevY;
                    
                    // Improved platform riding: Check if player is directly above platform
                    if (player.currentPlatform === platform && player.grounded) {
                        // Apply platform movement to player
                        player.x += dx;
                        
                        // For vertical movement, directly set Y position relative to platform top
                        // This prevents "falling through" when platform moves down quickly
                        player.y = platform.y - player.height;
                        
                        // Set flag that player is on a moving platform
                        playerOnMovingPlatform = true;
                    }
                }
            }
            
            // Second - Apply player controls with further reduced acceleration
            if (keys['ArrowLeft'] || keys['a']) {
                if (player.velX > -player.speed) {
                    // Reduced acceleration by 20% (0.2 instead of 0.25)
                    player.velX -= 0.2 * deltaTime;
                    // Set a minimum speed when key is pressed to feel more responsive
                    if (Math.abs(player.velX) < player.speed * 0.5 && player.velX < 0) {
                        player.velX = -player.speed * 0.5;
                    }
                }
            }
            
            if (keys['ArrowRight'] || keys['d']) {
                if (player.velX < player.speed) {
                    // Reduced acceleration by 20% (0.2 instead of 0.25)
                    player.velX += 0.2 * deltaTime;
                    // Set a minimum speed when key is pressed to feel more responsive
                    if (Math.abs(player.velX) < player.speed * 0.5 && player.velX > 0) {
                        player.velX = player.speed * 0.5;
                    }
                }
            }
            
            // Only apply physics if not standing on a platform or if jumping
            if (!player.grounded || player.jumping) {
                // Apply physics with delta time
                player.velX *= Math.pow(friction, deltaTime);
                player.velY += gravity * deltaTime;
                
                // Ensure terminal velocity
                if (player.velY > 15) {
                    player.velY = 15;
                }
                
                player.x += player.velX * deltaTime;
                player.y += player.velY * deltaTime;
            } else {
                // If grounded on a platform but moving horizontally
                if (Math.abs(player.velX) > 0.1) {
                    player.velX *= Math.pow(friction, deltaTime);
                    player.x += player.velX * deltaTime;
                } else {
                    player.velX = 0; // Stop any tiny residual movement
                }
                
                // Zero out vertical velocity when grounded
                player.velY = 0;
            }
            
            // Keep player in bounds (relative to world, not just camera)
            if (player.x < 0) {
                player.x = 0;
            }
            
            // Update lava effects (only those in view)
            for (const lava of lavas) {
                // Only update lava that's in or near the camera view
                if (lava.x + lava.width >= camera.x - 100 && lava.x <= camera.x + camera.width + 100) {
                    lava.update(deltaTime);
                }
            }
            
            // Update lava bubbles
            for (const bubble of lavaBubbles) {
                // Only update those in or near camera view
                if (Math.abs(bubble.x - (camera.x + camera.width/2)) < camera.width) {
                    bubble.update(deltaTime, player.x, player.y);
                }
            }
            
            // Update goal
            if (goal) {
                goal.update(deltaTime);
            }
            
            // Check for collisions
            checkCollisions();
            
            // Draw game elements with camera offset
            ctx.save();
            
            // Draw platforms (only those in view)
            for (const platform of platforms) {
                // Check if platform is in or near camera view to improve performance
                if (platform.x + platform.width >= camera.x - 50 && platform.x <= camera.x + camera.width + 50) {
                    platform.draw(ctx, camera.x);
                }
            }
            
            // Draw lava (only those in view)
            for (const lava of lavas) {
                if (lava.x + lava.width >= camera.x - 50 && lava.x <= camera.x + camera.width + 50) {
                    lava.draw(ctx, camera.x);
                }
            }
            
            // Draw lava bubbles
            for (const bubble of lavaBubbles) {
                if (Math.abs(bubble.x - (camera.x + camera.width/2)) < camera.width) {
                    bubble.draw(ctx, camera.x);
                }
            }
            
            // Draw goal
            if (goal) {
                goal.draw(ctx, camera.x);
            }
            
            // Draw player
            player.draw();
            
            ctx.restore();
            
            // Draw level info (fixed position, not affected by camera)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(canvas.width - 150, 10, 140, 30);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`Level: ${level}`, canvas.width - 20, 32);
            
            // Continue the game loop
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // Restart level function
        function restartLevel() {
            // Play death sound
            AudioManager.playSfx('death');
            
            player.x = 50;
            player.y = 300;
            player.velX = 0;
            player.velY = 0;
            deaths++;
            deathCounter.textContent = deaths;
            
            // Show game over screen briefly
            gameOverScreen.style.display = 'block';
            
            // Properly pause the game
            isPaused = true;
            
            setTimeout(() => {
                gameOverScreen.style.display = 'none';
                isPaused = false;
                lastTime = 0; // Reset time
                
                // No need to call gameLoop again as it's already running
            }, 1500);
        }
        
        // Level complete function
        function levelComplete() {
            // Play level complete sound
            AudioManager.playSfx('levelComplete');
            
            // Hide the player temporarily
            const oldPlayerX = player.x;
            const oldPlayerY = player.y;
            player.x = -100;
            player.y = -100;
            
            // Show level up screen
            level++;
            levelCounter.textContent = level;
            nextLevelDisplay.textContent = level;
            levelUpScreen.style.display = 'block';
            
            // Pause the game but keep animation running
            isPaused = true;
            
            // Generate new level and reset player after a short delay
            setTimeout(() => {
                levelUpScreen.style.display = 'none';
                generateLevel(level);
                player.x = 50;
                player.y = 300;
                player.velX = 0;
                player.velY = 0;
                isPaused = false;
                lastTime = 0; // Reset time
                
                // No need to call gameLoop again as it's already running
            }, 2000);
        }
        
        // Game over function (when player dies and chooses not to continue)
        function gameOver() {
            // Check if run should be recorded in leaderboard
            if (!runEnded && checkForHighScore()) {
                runEnded = true; // Mark run as ended to prevent multiple prompts
                
                // Show pause menu for name entry
                pauseLevelDisplay.textContent = level;
                pauseDeathsDisplay.textContent = deaths;
                pauseMenu.style.display = 'block';
            } else {
                // Reset game state for a new game
                resetGame();
            }
        }
        
        // Reset game state for a new run
        function resetGame() {
            level = 1;
            deaths = 0;
            levelCounter.textContent = level;
            deathCounter.textContent = deaths;
            generateLevel(level);
            runEnded = false;
            
            // Reset player position
            player.x = 50;
            player.y = 300;
            player.velX = 0;
            player.velY = 0;
        }
        
        // Button event listeners
        restartButton.addEventListener('click', function() {
            gameOverScreen.style.display = 'none';
            isPaused = false;
            lastTime = 0; // Reset time
            // Game loop continues automatically
        });
        
        // Save & End Run button listener
        saveEndButton.addEventListener('click', function() {
            const playerName = playerNameInput.value.trim() || 'Anonymous';
            
            // Add to leaderboard
            addLeaderboardEntry(playerName, level, deaths);
            
            // Hide pause menu
            pauseMenu.style.display = 'none';
            
            // Show leaderboard screen
            updateLeaderboardDisplay();
            leaderboardScreen.style.display = 'block';
            
            // Keep game paused while showing leaderboard
            isPaused = true;
        });
        
        // Continue Run button listener
        continueButton.addEventListener('click', function() {
            // Hide pause menu
            pauseMenu.style.display = 'none';
            
            // Resume game
            isPaused = false;
            lastTime = 0;
        });
        
        // New Game button in leaderboard listener
        newGameButton.addEventListener('click', function() {
            // Hide leaderboard screen
            leaderboardScreen.style.display = 'none';
            
            // Reset and start new game
            resetGame();
            
            // Unpause game
            isPaused = false;
            lastTime = 0;
        });
        
        // Player name input handling
        playerNameInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                saveEndButton.click();
            }
        });
        
        // Initial draw function
        function initialDraw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#001133');
            bgGradient.addColorStop(1, '#330011');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw game elements
            for (const platform of platforms) {
                platform.draw(ctx, 0);
            }
            
            for (const lava of lavas) {
                lava.draw(ctx, 0);
            }
            
            if (goal) {
                goal.draw(ctx, 0);
            }
            
            // Draw player
            player.draw();
            
            // Start message
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Press any key to start', canvas.width / 2, canvas.height / 2);
            ctx.fillText('(Press P or ESC to pause)', canvas.width / 2, canvas.height / 2 + 30);
        }
        
        // Load leaderboard from localStorage
        loadLeaderboard();
        // Function to show leaderboard from nav
function showLeaderboardScreen() {
    // Update leaderboard display
    updateLeaderboardDisplay();
    
    // Show leaderboard screen and pause game
    leaderboardScreen.style.display = 'block';
    isPaused = true;
    
    // Play menu click sound
    AudioManager.playSfx('menuClick');
}
    </script>
</body>
</html>
